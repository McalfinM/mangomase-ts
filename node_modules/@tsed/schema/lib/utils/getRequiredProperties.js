"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequiredProperties = void 0;
const core_1 = require("@tsed/core");
const alterRequiredGroups_1 = require("../hooks/alterRequiredGroups");
function applyStringRule(obj, propSchema) {
    if (!(propSchema === null || propSchema === void 0 ? void 0 : propSchema.$allow.includes(""))) {
        if ((propSchema === null || propSchema === void 0 ? void 0 : propSchema.get("type")) === "string") {
            const minLength = obj === null || obj === void 0 ? void 0 : obj.minLength;
            // Disallow empty string
            if (minLength === undefined) {
                return {
                    ...obj,
                    minLength: 1
                };
            }
        }
    }
    return obj;
}
function applyNullRule(obj, propSchema) {
    if (propSchema === null || propSchema === void 0 ? void 0 : propSchema.$allow.includes(null)) {
        if (propSchema.isClass) {
            return {
                oneOf: [
                    {
                        type: "null"
                    },
                    obj
                ]
            };
        }
        else {
            return {
                ...obj,
                type: core_1.uniq([].concat(obj.type, "null"))
            };
        }
    }
    return obj;
}
function mapRequiredProps(obj, schema, options = {}) {
    const { useAlias } = options;
    const props = Object.keys(obj.properties || {});
    return (keys, key) => {
        const aliasedKey = useAlias ? schema.alias.get(key) || key : key;
        if (props.includes(aliasedKey)) {
            const propSchema = schema.get("properties")[key];
            const serializeSchema = obj.properties[aliasedKey];
            obj.properties[aliasedKey] = applyNullRule(applyStringRule(serializeSchema, propSchema), propSchema);
            return keys.concat(aliasedKey);
        }
        return keys;
    };
}
function extractRequiredProps(obj, schema, options) {
    let required = obj.required || [];
    required = [...required, ...schema.$required];
    if (schema.get("properties")) {
        required = Object.entries(schema.get("properties")).reduce((required, [key, prop]) => {
            if (prop && prop.$selfRequired !== undefined) {
                return prop.$selfRequired ? required.concat(key) : required.filter((k) => k === key);
            }
            return required;
        }, required);
    }
    return alterRequiredGroups_1.alterRequiredGroups(core_1.uniq(required), schema, options);
}
/**
 * @ignore
 */
function getRequiredProperties(obj, schema, options) {
    let required = extractRequiredProps(obj, schema, options);
    required = core_1.uniq(required).reduce(mapRequiredProps(obj, schema, options), []);
    if (required.length) {
        return {
            ...obj,
            required
        };
    }
    return obj;
}
exports.getRequiredProperties = getRequiredProperties;
//# sourceMappingURL=getRequiredProperties.js.map